

[TOC]



# 常用算法实现

## 1、 稀疏矩阵

​	在一个较大的矩阵中，非零元素s相对于矩阵元素总个数t来说很z小时，即（s<t）;则称该矩阵为稀疏矩阵；若对稀疏矩阵中的每个元素都分配一个内存空间，则会造成极大的浪费。

​	为避免浪费，我们仅关注稀疏矩阵中的非零元素，稀疏矩阵采用三元组的方式存储，具体方式如下：

- 先扫描稀疏矩阵 ，以count记录非零元素个数；
- 声明一个二维数组count*2，第一行第一个元素记录矩阵的行数，第一行第二个元素记录矩阵的列数，第一行第三个元素记录 非零元素的个数；
- 从第二行起，第一个元素代表非零元素在原矩阵的行数，第二个元素代表非零元素在原矩阵的列数，第三个元素代表矩阵的值。 

```java
	// 稀疏矩阵转三元
	public int[][] toTri(int[][] orial){
		int row=orial.length;
		int line=orial[1].length;
		int cout=0;

		for (int i=0;i<row;i++) {
			for (int j=0;j<line ;j++ ) {
				if(orial[i][j]!=0){
					count++;
				}
			}
		}

		int[][] tri=new int[count+1][2];
		tri[0][0]=row;
		tri[0][1]=line;
		tri[0][2]=count;
		flag=0;

		for (int i=0;i<row ;i++ ) {
			for (int j=0;j<line ;j++ ) {
				if(orial[i][j]!=0){
					flag++;
					tri[flag][0]=i;
					tri[flag][1]=j;
					tri[flag][2]=orial[i][j]
				}
			}
		}
		return tri;
	}
```


```java
//三元转稀疏矩阵
	public int[][] toOri(int[][] tri){
		int row=tri[0][0];
		int line=tri[0][1];
		int count=tri[0][2];

		int[][] ori =new int[row][line];

		for (int k=0;k<count+1;k++) {
			ori[tir[k][0]][tri[k][1]]=tri[k][2];
		}

		return ori;
	}

```



## 2、 约瑟夫环

​	**问题描述**：已知n个人(以编号1，2，3...n分别表示)围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列;他的下一个人又从1开始报数，数到m的那个人又出列;依此规律重复下去，直到圆桌周围的人全部出列。

### 2.1 环形链表实现

### 2.2 使用递推公式实现

​	若是以环形链表模拟，约瑟夫环的求解算法，**若n的数量较大**，采用模拟的方式需要用**大量的时间模拟退出的过程**，并且需要**占用大量的内存空间模拟内存中的每个人**；

​	在大部分情况下，我们仅仅需要知道最后那个人的编号，而不是要来模拟一个这样的过程，在这种情况下，可以考虑是否存在着一种数学公式能够直接求出最后那个人的编号。

 - 将初始化的n个人，从0至n-1标号；

 - 第一个出列的人的标号一定为m%n-1,剩下的n-1个人，重新构成一个新的约瑟夫环，然后以编号m%n（设为K) 作为起点，重新开始编号并开始报号；

 - 原编号与新编号的之间的映射关系

   原编号：k、k+1、k+2......n-1、0、1、k-3、k-2

   新编号：0、1、2、3......n-k-1、n-k、n-k+1、n-3、n-2

   综上，就是将原问题中的n ，替换成 n-1;

   设最终胜利的那个人在这种编号环境里（已经出列一个元素，编号范围为0 ------- n-2）的编号为x;

   则我们可以求出这个人在原编号环境（初始编号范围 0----n-1）下的编号（x+k）%n;递推可得；

$$
f(n,m)=\begin{cases} 0,(n=1)\\ [f(n-1,m)+m]\%n， (n>1)\end{cases}
$$



- 方法一：递归的方式实现

```java
	// n 表示有 n个人
	//m表示数 m次
	public int JoseLoop(int n,int m){
		if (n==0){
			return -1;
		}else if(n==1){
			return 1;
		}else{
			return JoseLoop(n-1,m);
		}
	}

```

- 方法二： 内循环

```java
// n 表示有 n个人
//m表示数 m次
public int JoseLoop(int n, int m) {
	        if(n == 0 || m <= 0) {
	            return -1;
	        }
	        int last = 0;
	        for(int i = 2; i <= n; i++) {
	            last = (last + m) % i;
	        }
	        return last;
	    }
```

## 3、中缀表达式转后缀

​	**中缀表达式：**日常我们常见的数学表达式（1+2*3），操作数在运算符两边，便于我们日常理解，但不方便计算机进行运算；

​	**后缀表达式：**操作数在前，运算符在后，计算机方便理解的表达式（123*+）；

​	**中缀表达式转为后缀表达式**：从**左到右**遍历中缀表达式的每一个数字和符号，若是数字就输出，即为后缀表达式中的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号则栈顶元素（符号）依次出栈并输出并将当前符号进栈（ps：若当前符号优先级与栈顶相同则弹出栈顶元素并输出），一直到最终输出后缀表达式为止。

1. 初始化两个栈**operatorStack(存放运算符)，numberStack(存放中间结果)**

2. 从左至右扫描中缀表达式；

3. 遇到操作数时压入numberStack;

4. 遇到运算符时，比较其与operatorStack栈顶元素的优先级；

   4.1若operatorStack为空，或operatorStack栈顶元素为“（”，则直接入栈；

   4.2若其比operatorStack栈顶元素优先级高，直接入栈；

   4.3 否则，将operatorStack栈顶的运算符弹出并压入到numberStack中，再次转到(4.1)与operatorStack中新的栈顶运算符相比较；

5. 遇到括号时：

   5.1如果是左括号“(”,直接压入；

   5.2如果是右括号“)”，则依次弹出operatorStack栈顶的运算符，并压入numberStack，直到遇到左括号为止，此时将这一对括号丢弃；

6. 重复依次扫描2-5步骤，直至表达式最右边；

7. 将operatorStack中剩余的运算符依次弹出并压入numberStack；

8. 依次弹出numberStack中的元素并输出，结果的**逆序即为**中缀表达式对应的后缀表达式;

**ForExample:**    **9+（3-1）*3+10/2**

  (1) 从左至右扫描，将9输出，+ （入栈； 输出：9

 (2) 遇到3输出，( - 入栈 ，1输出； 输出：9 3 1

 (3) 遇到运算符），因此 - 出栈并输出； 输出：9 3 1 -

 (4) 接下来是 * 运算符入栈，优先级高于 + ，因此不输出； 输出：9 3 1 -

 (5) 3输出，遇到 + ，优先级低于 * ，所以* 输出； 输出：9 3 1- 3*

 (6)没有比+ 更低优先级，所以全部出栈，并将当前符号“+” 进栈； 输出：9 3 1 -3 * +

 (6) 将10输出，/ 入栈 ，优先级高于 + 不输出； 输出 ：9 3 1 - 3* +10

 (7) 接下来是2输出，没有其他运算符入栈，所有运算符出栈并输出； 输出： 9 3 1 - 3*+10 2 /+

```java
	 /**
     *  将表达式转化为中缀表达式
     * @param expression  表达式
     * @return
     */
    public static List<String> toInfixExpressionList(String expression){
        List<String>  list = new ArrayList<String>();
        int index = 0;
        while(index < expression.length()){
            char ch = expression.charAt(index);
            if((ch < 48) || (ch > 57)){//当前字符非数字
                list.add(ch+"");
                index++;
            }else{//当前字符是数字
                String str = "";
                //查看当前字符下一位是不是数字
                while (index<expression.length() && expression.charAt(index) >= 48 && expression.charAt(index) <= 57){
                    str += ch;
                    index++;
                }
                list.add(str);
            }
        }
        return list;
    }


	/*
	* 设置操作符优先级
	*/
	public int operatorPriority(String operatior){
		int result=0;
		switch(operatior){
			case"+":
				result=1;
				break;
			case"-":
				result=1;
				break;
			case"*":
				result=2;
				break;
			case"/":
				result=2;
				break;
			case"%":
				result=2;
				break;
			default:
				System.out.println("不存在该运算符")；
				break;
		}

	}

	/*
	*中缀表达式转后缀表达式
	*/
	public List<String> toSuffixExpression(List<String> list){
		Stack<String> operatiorStack=new Stack<>();// 运算符栈
		Stack<String> numberStack=new Stack<>(); //存放中间结果栈

		for (String item:list) {
			if(item.matchs("\\d+")){// 若当项是数字，则进入运算数栈
				numberStack.push(item);
			}else if(item.equals("(")){//若当前项是"(",入运算符栈
				operatiorStack.push(item);
			}else if(item.equals(")")){// 若当前项是")",出运算符栈，入运算数栈，直至匹配到"("
				while(!operatiorStack.peek().equals("(")){
					numberStack.push(operatiorStack.pop())
				}
				operatiorStack.pop();	
			}else{//如果运算符栈不为空，且运算符栈栈顶元素优先级大于当前运算符优先级，则运算符栈出，运算数栈入；
				while(!operatiorStack.empty()&&operatorPriority(operatiorStack.peek())>=operatorPriority(item)){
					numberStack.push(operatiorStack.pop());
				}
				operatiorStack.push(item);
			}
		}
		while(!operatiorStack.empty()){//将 运算符栈相关元素压入运算数栈
			numberStack.push(operatiorStack.pop());
		}
		return numberStack;
		//最后将运算数栈相关元素逆序输出，则得到后缀表达式（逆波兰表达式）
	}


	/*
	*后缀表达式计算结果
	*/
	public int caculate(List<String> list){
		Stack<String> stack=new Stack(String);

		for (String item:list) {
			if(item.matchs("\\d+")){// 遇到运算数则直接入栈
				stack.push(item);
			}else{ //与操作符，则，栈顶两个元素出栈
				int num1=Integer.parseInt(stack.pop()); //
				int num2=Integer.parseInt(stack.pop());
				int sum=0;
				if(item.equals("-")){
					sum=num2-num1;
				}else if(item.equals("+")){
					sum=num1+num2;
				}else if(item.equals("*")){
					sum=num1*num2;
				}else if(item.equals("/")){
					sum=num2/num1;
				}
				stack.push(sum);//计算结果入栈
			}
		}
		return Integer.parseInt(stack.pop());
	}

```

## 4、链表的相关操作

### 4.1 获取单链表的倒数第K个节点

### 4.2 将两个有序单链表合并

​	将两个有序的链表合并为一个新链表，要求新的链表是通过拼接两个链表的节点来生成的。

```java
public class ListNode {
    int val;
    ListNode next = null;

}

// 递归实现
public ListNode mergeTwoLisdt(ListNode l1,ListNode l2){
    if (l1==null&& l2==null){
        return null;
    }
    if (l1==null){
        return l2;
    }
    if (l2==null){
        return l1;
    }

    ListNode l3=null;
    if (l1.val>l2.val){//比较两个节点的值的大小
        l3=l2;
        l3.next=mergeTwoLisdt(l1,l2.next);
    }else{
        l3=l1;
        l3.next=mergeTwoLisdt(l1.next,l2);
    }

    return l3;
}
```

## 5、栈的使用

​	8皇后问题；8X8的棋盘，上有八个皇后，各个皇后之间，不能处在同一行，或者同一列，或者处在同一对角线上，问一共有多少种解法；

思路：先将第一个皇后房子啊第一行第一列

第二个皇后放在第二行第一列，判断是否可行，若是不可行，则放在第二行，第二列，依次把所有的列数都尝试一遍，直到找到一个合适的位置

第三个皇后，参照第二个皇后的操作，类似；

说明：本该用一个二维数组，来模拟棋盘，但是，在算法实现中，可以用一个一维数组；

Arr[]={1,4,6,3,8,2,0,5}.  //处在第几位，就表示在第几行，数字的大小就表示在第几列；



## 6、排序算法

​	排序算法，就是将一组数据，依照指定的顺序，进行排列的过程；

​	大致可以分为两类，**内部排序**（将所有数据，都加载到内存中）进行排序；**外部排序**，（数据 量过大，无法加载到内存中，需要借助外部存储）进行排序；

​	常见的排序：

	- 内部排序 插入排序（直接插入排序、希尔排序）、选择排序（简单选择排序、堆排序）、交换排序（冒泡排序、快速排序）、归并排序、基数排序；
	- 外部排序；

**算法的时间复杂度：**

- 事后统计
- 事情估算

时间复杂度，当n无限大的时候，可以忽略次常数项、低次项、高次项的系数也可以忽略；

**常见的时间复杂度：**

O(1)<Ologn<O(n)<O(nlogn)<O(n*n)<0(n***n*n)<O(n的k次方)<O(2 的nc次方)

- 常数阶：无论代码执行多少行，只要没有循环等复杂结构，这个代码的时间复杂度就是O（1）；

- 对数阶：O(logn)

  ```java
  while(i<n){
      i=i*2;
  }
  ```

- 线性阶O（n）

  ```java 
  for(int i=0;i<n;i++){}
  ```

- 线性对数阶

  ```java
  for(int i=0;i<n;i++){
  	while(j<n){
  		j=j*2;
  	}
  }
  ```

- 平方阶

  ```java
  for(int i=0;i<n;i++){
  	for(int j=0;j<n;j++){
  		j=i;
  		j++;
  	}
  }
  ```

  

**平均时间复杂度、最坏时间复杂度**

**平均时间复杂度**：所有可能输入实例以等概率出现的情况下，该算法运行的时间；

**最坏时间复杂度**：最坏的情况下的输入，该算法的运行时间，一般，情况下，我们关注的是就是最坏时间复杂度；



### 6.1 冒泡排序

​	通过对，待排序的序列，从前向后（由下标较小的元素开始），一次比较相邻元素的值，若发现逆序，则交换；值较大的元素逐渐从前面的到后面移动，就像水底的气泡一样；

	- 一共进行数组-1 次的大循环；
	- 循环次数逐渐减少；
	- 如果发现在某趟排序中，没有发生一次交换，则，可以提前结束冒泡排序；（优化）

**基本版：**

```java
public static int[] bubbleSort(int arr[]) {
    int temp;
    for (int i = 0; i < arr.length - 1; i++) {//大循环，需要进行多少次排序
        for (int j = 0; j < arr.length - 1-i; j++) {
            if (arr[j] > arr[j + 1]) {
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
    }
    return arr;
}
```

**优化版：**

```java
public static int[] bubbleSort2(int arr[]) {
    int temp;
    boolean flag=false;  //定义一个变量，判断是否交换；
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - 1-i; j++) {
            if (arr[j] > arr[j + 1]) {
                flag=true;
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }

        System.out.println("the " +(i+1)+ " circule");
        System.out.println(Arrays.toString(arr));

        if (flag==false){//在排序中一次都没有交换过
            break;
        }else{
            flag=false; //重制flag，进行下一次判断；
        }
    }
    return arr;
}
```

### 6.2 选择排序

​	选择排序是指，从虚排序的数组中，按照指定规则选出某一元素，再依规定交换位置后达到排序的目的；

**第一次：**从a r r[0]-arr[n-1] 之间，选出最小值，与arr[0]交换位置；

**第二次：**从arr[1]-arr[n-1]之间选出最小值，与arr[1]交换位置；

........

依次类推，求出由小至大的一个有序数列；

选择排序，一共有数据.size -1轮排序；

```java
public static int[] seleteSort(int[] arr) {

    for (int j = 0; j < arr.length - 1; j++) {

        int min = arr[j];
        int minIndex = j;

        for (int i=j+1; i < arr.length; i++) {
            if (min > arr[i]) {
                min = arr[i];
                minIndex = i;
            }
        }

        // 正好，最小值处在数组首位
        if (minIndex!=j){
            arr[minIndex]=arr[j];
            arr[j]=min;
        }

    }

    return arr;
}
```

### 6.3 插入排序

​	将欲排序的元素以插入的地方时寻找该元素的适当的位置；将n个待排序的元素看成一个有序表，和一个无需表 ，开始的时候，有序列表中，只包含一个元素，无序表中有 n-1个元素，排序过程中，每次从无序表中取出一个元素，把它依次和有序表中元素进行比较，并将其插入到有序表中合适的位置，使其成为新的有序表；

```java
public static int[] insertSort(int[] arr) {
    /**
     * 1、insertIndex.=o 保证数组不越界
     * 2、insertVal<arr[insertIndex 待插入的数，还没找到插入的位置
     */

    for (int i = 1; i < arr.length; i++) {//默认 数组第一个数为有序，从第二个数开始比较并插入
        int insertVal = arr[i];  //记录待出入的值
        int insertIndex = i - 1;//记录待插入的位子

        while (insertIndex >= 0 && insertVal < arr[insertIndex]) {//如果插入的那个数比他前一个数小则，进入循环
            arr[insertIndex + 1] = arr[insertIndex];  //将插入的那个数的前一个数后移
            insertIndex--;
        }

        arr[insertIndex + 1] = insertVal;
    }

    return arr;
}
```

### 6.4 希尔排序

​	是一种对希尔排序对插入排序一种优化的排序，也称**缩小增量排序**；

