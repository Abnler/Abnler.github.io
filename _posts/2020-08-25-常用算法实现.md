

[TOC]



# 常用算法实现

## 1、 稀疏矩阵

​	在一个较大的矩阵中，非零元素s相对于矩阵元素总个数t来说很z小时，即（s<t）;则称该矩阵为稀疏矩阵；若对稀疏矩阵中的每个元素都分配一个内存空间，则会造成极大的浪费。

​	为避免浪费，我们仅关注稀疏矩阵中的非零元素，稀疏矩阵采用三元组的方式存储，具体方式如下：

- 先扫描稀疏矩阵 ，以count记录非零元素个数；
- 声明一个二维数组count*2，第一行第一个元素记录矩阵的行数，第一行第二个元素记录矩阵的列数，第一行第三个元素记录 非零元素的个数；
- 从第二行起，第一个元素代表非零元素在原矩阵的行数，第二个元素代表非零元素在原矩阵的列数，第三个元素代表矩阵的值。 

```java
	// 稀疏矩阵转三元
	public int[][] toTri(int[][] orial){
		int row=orial.length;
		int line=orial[1].length;
		int cout=0;

		for (int i=0;i<row;i++) {
			for (int j=0;j<line ;j++ ) {
				if(orial[i][j]!=0){
					count++;
				}
			}
		}

		int[][] tri=new int[count+1][2];
		tri[0][0]=row;
		tri[0][1]=line;
		tri[0][2]=count;
		flag=0;

		for (int i=0;i<row ;i++ ) {
			for (int j=0;j<line ;j++ ) {
				if(orial[i][j]!=0){
					flag++;
					tri[flag][0]=i;
					tri[flag][1]=j;
					tri[flag][2]=orial[i][j]
				}
			}
		}
		return tri;
	}
```


```java
//三元转稀疏矩阵
	public int[][] toOri(int[][] tri){
		int row=tri[0][0];
		int line=tri[0][1];
		int count=tri[0][2];

		int[][] ori =new int[row][line];

		for (int k=0;k<count+1;k++) {
			ori[tir[k][0]][tri[k][1]]=tri[k][2];
		}

		return ori;
	}

```



## 2、 约瑟夫环

​	**问题描述**：已知n个人(以编号1，2，3...n分别表示)围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列;他的下一个人又从1开始报数，数到m的那个人又出列;依此规律重复下去，直到圆桌周围的人全部出列。

### 2.1 环形链表实现

### 2.2 使用递推公式实现

​	若是以环形链表模拟，约瑟夫环的求解算法，**若n的数量较大**，采用模拟的方式需要用**大量的时间模拟退出的过程**，并且需要**占用大量的内存空间模拟内存中的每个人**；

​	在大部分情况下，我们仅仅需要知道最后那个人的编号，而不是要来模拟一个这样的过程，在这种情况下，可以考虑是否存在着一种数学公式能够直接求出最后那个人的编号。

 - 将初始化的n个人，从0至n-1标号；

 - 第一个出列的人的标号一定为m%n-1,剩下的n-1个人，重新构成一个新的约瑟夫环，然后以编号m%n（设为K) 作为起点，重新开始编号并开始报号；

 - 原编号与新编号的之间的映射关系

   原编号：k、k+1、k+2......n-1、0、1、k-3、k-2

   新编号：0、1、2、3......n-k-1、n-k、n-k+1、n-3、n-2

   综上，就是将原问题中的n ，替换成 n-1;

   设最终胜利的那个人在这种编号环境里（已经出列一个元素，编号范围为0 ------- n-2）的编号为x;

   则我们可以求出这个人在原编号环境（初始编号范围 0----n-1）下的编号（x+k）%n;递推可得；

$$
f(n,m)=\begin{cases} 0,(n=1)\\ [f(n-1,m)+m]\%n， (n>1)\end{cases}
$$



- 方法一：递归的方式实现

```java
	// n 表示有 n个人
	//m表示数 m次
	public int JoseLoop(int n,int m){
		if (n==0){
			return -1;
		}else if(n==1){
			return 1;
		}else{
			return JoseLoop(n-1,m);
		}
	}

```

- 方法二： 内循环

```java
// n 表示有 n个人
//m表示数 m次
public int JoseLoop(int n, int m) {
	        if(n == 0 || m <= 0) {
	            return -1;
	        }
	        int last = 0;
	        for(int i = 2; i <= n; i++) {
	            last = (last + m) % i;
	        }
	        return last;
	    }
```

## 3、中缀表达式转后缀

​	**中缀表达式：**日常我们常见的数学表达式（1+2*3），操作数在运算符两边，便于我们日常理解，但不方便计算机进行运算；

​	**后缀表达式：**操作数在前，运算符在后，计算机方便理解的表达式（123*+）；

​	**中缀表达式转为后缀表达式**：从**左到右**遍历中缀表达式的每一个数字和符号，若是数字就输出，即为后缀表达式中的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号则栈顶元素（符号）依次出栈并输出并将当前符号进栈（ps：若当前符号优先级与栈顶相同则弹出栈顶元素并输出），一直到最终输出后缀表达式为止。

1. 初始化两个栈**operatorStack(存放运算符)，numberStack(存放中间结果)**

2. 从左至右扫描中缀表达式；

3. 遇到操作数时压入numberStack;

4. 遇到运算符时，比较其与operatorStack栈顶元素的优先级；

   4.1若operatorStack为空，或operatorStack栈顶元素为“（”，则直接入栈；

   4.2若其比operatorStack栈顶元素优先级高，直接入栈；

   4.3 否则，将operatorStack栈顶的运算符弹出并压入到numberStack中，再次转到(4.1)与operatorStack中新的栈顶运算符相比较；

5. 遇到括号时：

   5.1如果是左括号“(”,直接压入；

   5.2如果是右括号“)”，则依次弹出operatorStack栈顶的运算符，并压入numberStack，直到遇到左括号为止，此时将这一对括号丢弃；

6. 重复依次扫描2-5步骤，直至表达式最右边；

7. 将operatorStack中剩余的运算符依次弹出并压入numberStack；

8. 依次弹出numberStack中的元素并输出，结果的**逆序即为**中缀表达式对应的后缀表达式;

**ForExample:**    **9+（3-1）*3+10/2**

  (1) 从左至右扫描，将9输出，+ （入栈； 输出：9

 (2) 遇到3输出，( - 入栈 ，1输出； 输出：9 3 1

 (3) 遇到运算符），因此 - 出栈并输出； 输出：9 3 1 -

 (4) 接下来是 * 运算符入栈，优先级高于 + ，因此不输出； 输出：9 3 1 -

 (5) 3输出，遇到 + ，优先级低于 * ，所以* 输出； 输出：9 3 1- 3*

 (6)没有比+ 更低优先级，所以全部出栈，并将当前符号“+” 进栈； 输出：9 3 1 -3 * +

 (6) 将10输出，/ 入栈 ，优先级高于 + 不输出； 输出 ：9 3 1 - 3* +10

 (7) 接下来是2输出，没有其他运算符入栈，所有运算符出栈并输出； 输出： 9 3 1 - 3*+10 2 /+

```java
	 /**
     *  将表达式转化为中缀表达式
     * @param expression  表达式
     * @return
     */
    public static List<String> toInfixExpressionList(String expression){
        List<String>  list = new ArrayList<String>();
        int index = 0;
        while(index < expression.length()){
            char ch = expression.charAt(index);
            if((ch < 48) || (ch > 57)){//当前字符非数字
                list.add(ch+"");
                index++;
            }else{//当前字符是数字
                String str = "";
                //查看当前字符下一位是不是数字
                while (index<expression.length() && expression.charAt(index) >= 48 && expression.charAt(index) <= 57){
                    str += ch;
                    index++;
                }
                list.add(str);
            }
        }
        return list;
    }


	/*
	* 设置操作符优先级
	*/
	public int operatorPriority(String operatior){
		int result=0;
		switch(operatior){
			case"+":
				result=1;
				break;
			case"-":
				result=1;
				break;
			case"*":
				result=2;
				break;
			case"/":
				result=2;
				break;
			case"%":
				result=2;
				break;
			default:
				System.out.println("不存在该运算符")；
				break;
		}

	}

	/*
	*中缀表达式转后缀表达式
	*/
	public List<String> toSuffixExpression(List<String> list){
		Stack<String> operatiorStack=new Stack<>();// 运算符栈
		Stack<String> numberStack=new Stack<>(); //存放中间结果栈

		for (String item:list) {
			if(item.matchs("\\d+")){// 若当项是数字，则进入运算数栈
				numberStack.push(item);
			}else if(item.equals("(")){//若当前项是"(",入运算符栈
				operatiorStack.push(item);
			}else if(item.equals(")")){// 若当前项是")",出运算符栈，入运算数栈，直至匹配到"("
				while(!operatiorStack.peek().equals("(")){
					numberStack.push(operatiorStack.pop())
				}
				operatiorStack.pop();	
			}else{//如果运算符栈不为空，且运算符栈栈顶元素优先级大于当前运算符优先级，则运算符栈出，运算数栈入；
				while(!operatiorStack.empty()&&operatorPriority(operatiorStack.peek())>=operatorPriority(item)){
					numberStack.push(operatiorStack.pop());
				}
				operatiorStack.push(item);
			}
		}
		while(!operatiorStack.empty()){//将 运算符栈相关元素压入运算数栈
			numberStack.push(operatiorStack.pop());
		}
		return numberStack;
		//最后将运算数栈相关元素逆序输出，则得到后缀表达式（逆波兰表达式）
	}


	/*
	*后缀表达式计算结果
	*/
	public int caculate(List<String> list){
		Stack<String> stack=new Stack(String);

		for (String item:list) {
			if(item.matchs("\\d+")){// 遇到运算数则直接入栈
				stack.push(item);
			}else{ //与操作符，则，栈顶两个元素出栈
				int num1=Integer.parseInt(stack.pop()); //
				int num2=Integer.parseInt(stack.pop());
				int sum=0;
				if(item.equals("-")){
					sum=num2-num1;
				}else if(item.equals("+")){
					sum=num1+num2;
				}else if(item.equals("*")){
					sum=num1*num2;
				}else if(item.equals("/")){
					sum=num2/num1;
				}
				stack.push(sum);//计算结果入栈
			}
		}
		return Integer.parseInt(stack.pop());
	}

```



