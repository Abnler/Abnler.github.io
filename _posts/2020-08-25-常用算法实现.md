

# 常用算法实现

## 1、 稀疏矩阵

​	在一个较大的矩阵中，非零元素s相对于矩阵元素总个数t来说很z小时，即（s<t）;则称该矩阵为稀疏矩阵；若对稀疏矩阵中的每个元素都分配一个内存空间，则会造成极大的浪费。

​	为避免浪费，我们仅关注稀疏矩阵中的非零元素，稀疏矩阵采用三元组的方式存储，具体方式如下：

- 先扫描稀疏矩阵 ，以count记录非零元素个数；
- 声明一个二维数组count*2，第一行第一个元素记录矩阵的行数，第一行第二个元素记录矩阵的列数，第一行第三个元素记录 非零元素的个数；
- 从第二行起，第一个元素代表非零元素在原矩阵的行数，第二个元素代表非零元素在原矩阵的列数，第三个元素代表矩阵的值。 

```java
	// 稀疏矩阵转三元
	public int[][] toTri(int[][] orial){
		int row=orial.length;
		int line=orial[1].length;
		int cout=0;

		for (int i=0;i<row;i++) {
			for (int j=0;j<line ;j++ ) {
				if(orial[i][j]!=0){
					count++;
				}
			}
		}

		int[][] tri=new int[count+1][2];
		tri[0][0]=row;
		tri[0][1]=line;
		tri[0][2]=count;
		flag=0;

		for (int i=0;i<row ;i++ ) {
			for (int j=0;j<line ;j++ ) {
				if(orial[i][j]!=0){
					flag++;
					tri[flag][0]=i;
					tri[flag][1]=j;
					tri[flag][2]=orial[i][j]
				}
			}
		}
		return tri;
	}
```


```java
//三元转稀疏矩阵
	public int[][] toOri(int[][] tri){
		int row=tri[0][0];
		int line=tri[0][1];
		int count=tri[0][2];

		int[][] ori =new int[row][line];

		for (int k=0;k<count+1;k++) {
			ori[tir[k][0]][tri[k][1]]=tri[k][2];
		}

		return ori;
	}

```



## 2、 约瑟夫环

​	**问题描述**：已知n个人(以编号1，2，3...n分别表示)围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列;他的下一个人又从1开始报数，数到m的那个人又出列;依此规律重复下去，直到圆桌周围的人全部出列。

### 2.1 环形链表实现

### 2.2 使用递推公式实现

​	若是以环形链表模拟，约瑟夫环的求解算法，**若n的数量较大**，采用模拟的方式需要用**大量的时间模拟退出的过程**，并且需要**占用大量的内存空间模拟内存中的每个人**；

​	在大部分情况下，我们仅仅需要知道最后那个人的编号，而不是要来模拟一个这样的过程，在这种情况下，可以考虑是否存在着一种数学公式能够直接求出最后那个人的编号。

 - 将初始化的n个人，从0至n-1标号；

 - 第一个出列的人的标号一定为m%n-1,剩下的n-1个人，重新构成一个新的约瑟夫环，然后以编号m%n（设为K) 作为起点，重新开始编号并开始报号；

 - 原编号与新编号的之间的映射关系

   原编号：k、k+1、k+2......n-1、0、1、k-3、k-2

   新编号：0、1、2、3......n-k-1、n-k、n-k+1、n-3、n-2

   综上，就是将原问题中的n ，替换成 n-1;

   设最终胜利的那个人在这种编号环境里（已经出列一个元素，编号范围为0 ------- n-2）的编号为x;

   则我们可以求出这个人在原编号环境（初始编号范围 0----n-1）下的编号（x+k）%n;递推可得；

$$
f(n,m)=\begin{cases} 0,(n=1)\\ [f(n-1,m)+m]\%n， (n>1)\end{cases}
$$



- 方法一：递归的方式实现

```java
	// n 表示有 n个人
	//m表示数 m次
	public int JoseLoop(int n,int m){
		if (n==0){
			return -1;
		}else if(n==1){
			return 1;
		}else{
			return JoseLoop(n-1,m);
		}
	}

```

- 方法二： 内循环

```java
// n 表示有 n个人
//m表示数 m次
public int JoseLoop(int n, int m) {
	        if(n == 0 || m <= 0) {
	            return -1;
	        }
	        int last = 0;
	        for(int i = 2; i <= n; i++) {
	            last = (last + m) % i;
	        }
	        return last;
	    }
```





