

[TOC]



# 常用算法实现

## 1、 稀疏矩阵

​	在一个较大的矩阵中，非零元素s相对于矩阵元素总个数t来说很z小时，即（s<t）;则称该矩阵为稀疏矩阵；若对稀疏矩阵中的每个元素都分配一个内存空间，则会造成极大的浪费。

​	为避免浪费，我们仅关注稀疏矩阵中的非零元素，稀疏矩阵采用三元组的方式存储，具体方式如下：

- 先扫描稀疏矩阵 ，以count记录非零元素个数；
- 声明一个二维数组count*2，第一行第一个元素记录矩阵的行数，第一行第二个元素记录矩阵的列数，第一行第三个元素记录 非零元素的个数；
- 从第二行起，第一个元素代表非零元素在原矩阵的行数，第二个元素代表非零元素在原矩阵的列数，第三个元素代表矩阵的值。 

```java
	// 稀疏矩阵转三元
	public int[][] toTri(int[][] orial){
		int row=orial.length;
		int line=orial[1].length;
		int cout=0;

		for (int i=0;i<row;i++) {
			for (int j=0;j<line ;j++ ) {
				if(orial[i][j]!=0){
					count++;
				}
			}
		}

		int[][] tri=new int[count+1][2];
		tri[0][0]=row;
		tri[0][1]=line;
		tri[0][2]=count;
		flag=0;

		for (int i=0;i<row ;i++ ) {
			for (int j=0;j<line ;j++ ) {
				if(orial[i][j]!=0){
					flag++;
					tri[flag][0]=i;
					tri[flag][1]=j;
					tri[flag][2]=orial[i][j]
				}
			}
		}
		return tri;
	}
```


```java
//三元转稀疏矩阵
	public int[][] toOri(int[][] tri){
		int row=tri[0][0];
		int line=tri[0][1];
		int count=tri[0][2];

		int[][] ori =new int[row][line];

		for (int k=0;k<count+1;k++) {
			ori[tir[k][0]][tri[k][1]]=tri[k][2];
		}

		return ori;
	}

```



## 2、 约瑟夫环

​	**问题描述**：已知n个人(以编号1，2，3...n分别表示)围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列;他的下一个人又从1开始报数，数到m的那个人又出列;依此规律重复下去，直到圆桌周围的人全部出列。

### 2.1 环形链表实现

### 2.2 使用递推公式实现

​	若是以环形链表模拟，约瑟夫环的求解算法，**若n的数量较大**，采用模拟的方式需要用**大量的时间模拟退出的过程**，并且需要**占用大量的内存空间模拟内存中的每个人**；

​	在大部分情况下，我们仅仅需要知道最后那个人的编号，而不是要来模拟一个这样的过程，在这种情况下，可以考虑是否存在着一种数学公式能够直接求出最后那个人的编号。

 - 将初始化的n个人，从0至n-1标号；

 - 第一个出列的人的标号一定为m%n-1,剩下的n-1个人，重新构成一个新的约瑟夫环，然后以编号m%n（设为K) 作为起点，重新开始编号并开始报号；

 - 原编号与新编号的之间的映射关系

   原编号：k、k+1、k+2......n-1、0、1、k-3、k-2

   新编号：0、1、2、3......n-k-1、n-k、n-k+1、n-3、n-2

   综上，就是将原问题中的n ，替换成 n-1;

   设最终胜利的那个人在这种编号环境里（已经出列一个元素，编号范围为0 ------- n-2）的编号为x;

   则我们可以求出这个人在原编号环境（初始编号范围 0----n-1）下的编号（x+k）%n;递推可得；

$$
f(n,m)=\begin{cases} 0,(n=1)\\ [f(n-1,m)+m]\%n， (n>1)\end{cases}
$$



- 方法一：递归的方式实现

```java
	// n 表示有 n个人
	//m表示数 m次
	public int JoseLoop(int n,int m){
		if (n==0){
			return -1;
		}else if(n==1){
			return 1;
		}else{
			return JoseLoop(n-1,m);
		}
	}

```

- 方法二： 内循环

```java
// n 表示有 n个人
//m表示数 m次
public int JoseLoop(int n, int m) {
	        if(n == 0 || m <= 0) {
	            return -1;
	        }
	        int last = 0;
	        for(int i = 2; i <= n; i++) {
	            last = (last + m) % i;
	        }
	        return last;
	    }
```

## 3、中缀表达式转后缀

​	**中缀表达式：**日常我们常见的数学表达式（1+2*3），操作数在运算符两边，便于我们日常理解，但不方便计算机进行运算；

​	**后缀表达式：**操作数在前，运算符在后，计算机方便理解的表达式（123*+）；

​	**中缀表达式转为后缀表达式**：从**左到右**遍历中缀表达式的每一个数字和符号，若是数字就输出，即为后缀表达式中的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号则栈顶元素（符号）依次出栈并输出并将当前符号进栈（ps：若当前符号优先级与栈顶相同则弹出栈顶元素并输出），一直到最终输出后缀表达式为止。

1. 初始化两个栈**operatorStack(存放运算符)，numberStack(存放中间结果)**

2. 从左至右扫描中缀表达式；

3. 遇到操作数时压入numberStack;

4. 遇到运算符时，比较其与operatorStack栈顶元素的优先级；

   4.1若operatorStack为空，或operatorStack栈顶元素为“（”，则直接入栈；

   4.2若其比operatorStack栈顶元素优先级高，直接入栈；

   4.3 否则，将operatorStack栈顶的运算符弹出并压入到numberStack中，再次转到(4.1)与operatorStack中新的栈顶运算符相比较；

5. 遇到括号时：

   5.1如果是左括号“(”,直接压入；

   5.2如果是右括号“)”，则依次弹出operatorStack栈顶的运算符，并压入numberStack，直到遇到左括号为止，此时将这一对括号丢弃；

6. 重复依次扫描2-5步骤，直至表达式最右边；

7. 将operatorStack中剩余的运算符依次弹出并压入numberStack；

8. 依次弹出numberStack中的元素并输出，结果的**逆序即为**中缀表达式对应的后缀表达式;

**ForExample:**    **9+（3-1）*3+10/2**

  (1) 从左至右扫描，将9输出，+ （入栈； 输出：9

 (2) 遇到3输出，( - 入栈 ，1输出； 输出：9 3 1

 (3) 遇到运算符），因此 - 出栈并输出； 输出：9 3 1 -

 (4) 接下来是 * 运算符入栈，优先级高于 + ，因此不输出； 输出：9 3 1 -

 (5) 3输出，遇到 + ，优先级低于 * ，所以* 输出； 输出：9 3 1- 3*

 (6)没有比+ 更低优先级，所以全部出栈，并将当前符号“+” 进栈； 输出：9 3 1 -3 * +

 (6) 将10输出，/ 入栈 ，优先级高于 + 不输出； 输出 ：9 3 1 - 3* +10

 (7) 接下来是2输出，没有其他运算符入栈，所有运算符出栈并输出； 输出： 9 3 1 - 3*+10 2 /+

```java
	 /**
     *  将表达式转化为中缀表达式
     * @param expression  表达式
     * @return
     */
    public static List<String> toInfixExpressionList(String expression){
        List<String>  list = new ArrayList<String>();
        int index = 0;
        while(index < expression.length()){
            char ch = expression.charAt(index);
            if((ch < 48) || (ch > 57)){//当前字符非数字
                list.add(ch+"");
                index++;
            }else{//当前字符是数字
                String str = "";
                //查看当前字符下一位是不是数字
                while (index<expression.length() && expression.charAt(index) >= 48 && expression.charAt(index) <= 57){
                    str += ch;
                    index++;
                }
                list.add(str);
            }
        }
        return list;
    }


	/*
	* 设置操作符优先级
	*/
	public int operatorPriority(String operatior){
		int result=0;
		switch(operatior){
			case"+":
				result=1;
				break;
			case"-":
				result=1;
				break;
			case"*":
				result=2;
				break;
			case"/":
				result=2;
				break;
			case"%":
				result=2;
				break;
			default:
				System.out.println("不存在该运算符")；
				break;
		}

	}

	/*
	*中缀表达式转后缀表达式
	*/
	public List<String> toSuffixExpression(List<String> list){
		Stack<String> operatiorStack=new Stack<>();// 运算符栈
		Stack<String> numberStack=new Stack<>(); //存放中间结果栈

		for (String item:list) {
			if(item.matchs("\\d+")){// 若当项是数字，则进入运算数栈
				numberStack.push(item);
			}else if(item.equals("(")){//若当前项是"(",入运算符栈
				operatiorStack.push(item);
			}else if(item.equals(")")){// 若当前项是")",出运算符栈，入运算数栈，直至匹配到"("
				while(!operatiorStack.peek().equals("(")){
					numberStack.push(operatiorStack.pop())
				}
				operatiorStack.pop();	
			}else{//如果运算符栈不为空，且运算符栈栈顶元素优先级大于当前运算符优先级，则运算符栈出，运算数栈入；
				while(!operatiorStack.empty()&&operatorPriority(operatiorStack.peek())>=operatorPriority(item)){
					numberStack.push(operatiorStack.pop());
				}
				operatiorStack.push(item);
			}
		}
		while(!operatiorStack.empty()){//将 运算符栈相关元素压入运算数栈
			numberStack.push(operatiorStack.pop());
		}
		return numberStack;
		//最后将运算数栈相关元素逆序输出，则得到后缀表达式（逆波兰表达式）
	}


	/*
	*后缀表达式计算结果
	*/
	public int caculate(List<String> list){
		Stack<String> stack=new Stack(String);

		for (String item:list) {
			if(item.matchs("\\d+")){// 遇到运算数则直接入栈
				stack.push(item);
			}else{ //与操作符，则，栈顶两个元素出栈
				int num1=Integer.parseInt(stack.pop()); //
				int num2=Integer.parseInt(stack.pop());
				int sum=0;
				if(item.equals("-")){
					sum=num2-num1;
				}else if(item.equals("+")){
					sum=num1+num2;
				}else if(item.equals("*")){
					sum=num1*num2;
				}else if(item.equals("/")){
					sum=num2/num1;
				}
				stack.push(sum);//计算结果入栈
			}
		}
		return Integer.parseInt(stack.pop());
	}

```

## 4、链表的相关操作

### 4.1 获取单链表的倒数第K个节点

### 4.2 将两个有序单链表合并

​	将两个有序的链表合并为一个新链表，要求新的链表是通过拼接两个链表的节点来生成的。

```java
public class ListNode {
    int val;
    ListNode next = null;

}

// 递归实现
public ListNode mergeTwoLisdt(ListNode l1,ListNode l2){
    if (l1==null&& l2==null){
        return null;
    }
    if (l1==null){
        return l2;
    }
    if (l2==null){
        return l1;
    }

    ListNode l3=null;
    if (l1.val>l2.val){//比较两个节点的值的大小
        l3=l2;
        l3.next=mergeTwoLisdt(l1,l2.next);
    }else{
        l3=l1;
        l3.next=mergeTwoLisdt(l1.next,l2);
    }

    return l3;
}
```

## 5、栈的使用

​	8皇后问题；8X8的棋盘，上有八个皇后，各个皇后之间，不能处在同一行，或者同一列，或者处在同一对角线上，问一共有多少种解法；

思路：先将第一个皇后房子啊第一行第一列

第二个皇后放在第二行第一列，判断是否可行，若是不可行，则放在第二行，第二列，依次把所有的列数都尝试一遍，直到找到一个合适的位置

第三个皇后，参照第二个皇后的操作，类似；

说明：本该用一个二维数组，来模拟棋盘，但是，在算法实现中，可以用一个一维数组；

Arr[]={1,4,6,3,8,2,0,5}.  //处在第几位，就表示在第几行，数字的大小就表示在第几列；



## 6、排序算法

​	排序算法，就是将一组数据，依照指定的顺序，进行排列的过程；

​	大致可以分为两类，**内部排序**（将所有数据，都加载到内存中）进行排序；**外部排序**，（数据 量过大，无法加载到内存中，需要借助外部存储）进行排序；

​	常见的排序：

	- 内部排序 插入排序（直接插入排序、希尔排序）、选择排序（简单选择排序、堆排序）、交换排序（冒泡排序、快速排序）、归并排序、基数排序；
	- 外部排序；

**算法的时间复杂度：**

- 事后统计
- 事情估算

时间复杂度，当n无限大的时候，可以忽略次常数项、低次项、高次项的系数也可以忽略；

**常见的时间复杂度：**

O(1)<Ologn<O(n)<O(nlogn)<O(n*n)<0(n***n*n)<O(n的k次方)<O(2 的n次方)

- 常数阶：无论代码执行多少行，只要没有循环等复杂结构，这个代码的时间复杂度就是O（1）；

- 对数阶：O(logn)

  ```java
  while(i<n){
      i=i*2;
  }
  ```

- 线性阶O（n）

  ```java 
  for(int i=0;i<n;i++){}
  ```

- 线性对数阶

  ```java
  for(int i=0;i<n;i++){
  	while(j<n){
  		j=j*2;
  	}
  }
  ```

- 平方阶

  ```java
  for(int i=0;i<n;i++){
  	for(int j=0;j<n;j++){
  		j=i;
  		j++;
  	}
  }
  ```

  

**平均时间复杂度、最坏时间复杂度**

**平均时间复杂度**：所有可能输入实例以等概率出现的情况下，该算法运行的时间；

**最坏时间复杂度**：最坏的情况下的输入，该算法的运行时间，一般，情况下，我们关注的是就是最坏时间复杂度；



### 6.1 冒泡排序

​	通过对，待排序的序列，从前向后（由下标较小的元素开始），一次比较相邻元素的值，若发现逆序，则交换；值较大的元素逐渐从前面的到后面移动，就像水底的气泡一样；

```
- 一共进行数组-1 次的大循环；
- 循环次数逐渐减少；
- 如果发现在某趟排序中，没有发生一次交换，则，可以提前结束冒泡排序；（优化）
```

**基本版：**

```java
public static int[] bubbleSort(int arr[]) {
    int temp;
    for (int i = 0; i < arr.length - 1; i++) {//大循环，需要进行多少次排序
        for (int j = 0; j < arr.length - 1-i; j++) {
            if (arr[j] > arr[j + 1]) {
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
    }
    return arr;
}
```

**优化版：**

```java
public static int[] bubbleSort2(int arr[]) {
    int temp;
    boolean flag=false;  //定义一个变量，判断是否交换；
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - 1-i; j++) {
            if (arr[j] > arr[j + 1]) {
                flag=true;
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }

        System.out.println("the " +(i+1)+ " circule");
        System.out.println(Arrays.toString(arr));

        if (flag==false){//在排序中一次都没有交换过
            break;
        }else{
            flag=false; //重制flag，进行下一次判断；
        }
    }
    return arr;
}
```

### 6.2 选择排序

​	选择排序是指，从虚排序的数组中，按照指定规则选出某一元素，再依规定交换位置后达到排序的目的；

**第一次：**从a r r[0]-arr[n-1] 之间，选出最小值，与arr[0]交换位置；

**第二次：**从arr[1]-arr[n-1]之间选出最小值，与arr[1]交换位置；

........

依次类推，求出由小至大的一个有序数列；

选择排序，一共有数据.size -1轮排序；

```java
public static int[] seleteSort(int[] arr) {

    for (int j = 0; j < arr.length - 1; j++) {

        int min = arr[j];
        int minIndex = j;

        for (int i=j+1; i < arr.length; i++) {
            if (min > arr[i]) {
                min = arr[i];
                minIndex = i;
            }
        }

        // 正好，最小值处在数组首位
        if (minIndex!=j){
            arr[minIndex]=arr[j];
            arr[j]=min;
        }

    }

    return arr;
}
```

### 6.3 插入排序

​	将欲排序的元素以插入的地方时寻找该元素的适当的位置；将n个待排序的元素看成一个有序表，和一个无需表 ，开始的时候，有序列表中，只包含一个元素，无序表中有 n-1个元素，排序过程中，每次从无序表中取出一个元素，把它依次和有序表中元素进行比较，并将其插入到有序表中合适的位置，使其成为新的有序表；

```java
public static int[] insertSort(int[] arr) {
    /**
     * 1、insertIndex.=o 保证数组不越界
     * 2、insertVal<arr[insertIndex 待插入的数，还没找到插入的位置
     */

    for (int i = 1; i < arr.length; i++) {//默认 数组第一个数为有序，从第二个数开始比较并插入
        int insertVal = arr[i];  //记录待出入的值
        int insertIndex = i - 1;//记录待插入的位子

        while (insertIndex >= 0 && insertVal < arr[insertIndex]) {//如果插入的那个数比他前一个数小则，进入循环
            arr[insertIndex + 1] = arr[insertIndex];  //将插入的那个数的前一个数后移
            insertIndex--;
        }

        arr[insertIndex + 1] = insertVal;
    }

    return arr;
}
```

### 6.4 希尔排序

​	是一种对希尔排序对插入排序一种优化的排序，也称**缩小增量排序**；

**交换法**

```Java
public static int[] shellSort1(int[] arr) {

    for (int gap = arr.length / 2; gap > 0; gap /= 2) {//确定单步步长，将数组分组；
        for (int i = gap; i < arr.length; i++) {
            for (int j = i - gap; j >= 0; j -= gap) {
                if (arr[j] > arr[j + gap]) {
                    int temp = arr[j] + arr[j + gap];
                    arr[j + gap] = temp - arr[j + gap];
                    arr[j] = temp - arr[j];
                }
            }
        }
    }

    return arr;
}
```

移位法

```java
public static int[] shellSort2(int[] arr) {
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < arr.length; i++) {
            int j = i;
            int temp = arr[j];
            if (arr[j] < arr[j - gap]) {
                while (j - gap >= 0 && temp < arr[j - gap]) {  //对 分段后的数据，进行插入排序
                    arr[j] = arr[j - gap];
                    j -= gap;
                }
                //退出while循环后就找到了位子
                arr[j] = temp;
            }
        }
    }
    
    return arr;
}
```

### 6.5 快速排序

​	快排是对冒泡排序的一种改进；**基本思想：**通过一趟排序，将要排序的数据分割成独立的两个部分，其中一部分的所有数据比另一部分的所有数据要小，然后再按此方法，对这两部分分别进行快速排序。

```java
public static int[] quickSDort(int[] arr, int left, int right) {

    int l = left;//记录做下标
    int r = right;//记录右下标
    int pivot = arr[(left + right) / 2]; //中轴
    int temp = 0;// 临时变量，用于交换使用

    while (l < r) {// while 目的是让 pivot将数组划分为左右两边
        while (arr[l] < pivot) {// pivot 左边找比pivot大的数据，然后退出  从左往右扫描
            l += 1;
        }
        while (arr[r] > pivot) {//在pivot右边找比pivot小的数据，然后退出  从右往左扫描
            r -= 1;
        }
        if (l >= r) {  //若满足次条件，则说明，pivot 左边的数均比右边的小，则退出
            break;
        }

        //交换两个值
        temp = arr[l] + arr[r];
        arr[l] = temp - arr[l];
        arr[r] = temp - arr[r];

        if (arr[l] == pivot) {//如果交换完之后arr[l]==pivot相等，则前移 r--
            r -= 1;
        }

        if (arr[r] == pivot) {//如果交换完之后arr[r]==pivot相等，则后移 l++
            l += 1;
        }

        //以上两个判断是为了避免，l和r的值都等于pivot，为了避免死循环

    }


    //如果l==r 必须要 l++ ，以及r-- 否则会出现栈溢出；
    if (l == r) {
        l++;
        r--;
    }

    //向左递归
    if (left < r) {
        quickSDort(arr, left, r);
    }

    //向右递归
    if (right > l) {
        quickSDort(arr,l,right);
    }
    return arr;
}
```

### 6.6 归并排序

​	采用分治算法，将一个大的问题分解成多个小问题，然后将问题解决；

### 6.7 基数排序

​	基数排序：将整数切割成不同的位数，然后在根据位数进行比较；从低位开始，依次进行一次排序；这样从低位到高位一次完成排序后，数列就有序了，将所有的带比较数值，统一为同一数位长度，数位较短的在前面补0；

## 7、查找算法

### 7.1 线性查找

### 7.2 二分查找

​	首先，二分查找要求数组有序；思路如下：

- 确定数组中间下标
- Find value 与a r r[mid]比较
- Find vale >arr[mid]. 向右递归
- findvalue<arr[mid]向左递归
- findvale=arr[mid] 找到

递归出口：

- 目标数据已查到，退出；
- 当left>right 表示，没有找到相关数据，退出

```java
/**
 *
 * @param arr 已经有序的数组
 * @param left 左下标
 * @param right 右下标
 * @param findval 待查找的值
 * @return  返回-1 代表未找到
 */
public static int BinarySearch(int[] arr, int left, int right, int findval) {

    if (left>right){
        return -1;
    }

    int mid=(left+right)/2;
    int midValue=arr[mid];

    if (findval>midValue){  //向右递归
        return BinarySearch(arr,mid+1,right,findval);
    }else if (findval<midValue){  //向左递归
        return BinarySearch(arr,left,mid-1,findval);
    }else (findval==midValue){  //已找到
        return mid;
    }
}
```

```java
/**
 * 对二分查找的优化，在数组中有多个数存在，则，返回这个所在下标的集合
 * @param arr 
 * @param left
 * @param right
 * @param findval
 * @return
 */
public static ArrayList<Integer> BinarySearch1(int[] arr, int left, int right, int findval) {

    if (left > right) {
        return new ArrayList<Integer>();
    }

    int mid = (left + right) / 2;
    int midValue = arr[mid];

    if (findval > midValue) {  //向右递归
        return BinarySearch1(arr, mid + 1, right, findval);
    } else if (findval < midValue) {  //向左递归
        return BinarySearch1(arr, left, mid - 1, findval);
    } else (findval == midValue) {  //已找到
        ArrayList<Integer> arrayList = new ArrayList<>();
        int temp = mid - 1;
        while (true) {
            if (temp < 0 || arr[temp] != findval) {
                break;
            }
            arrayList.add(temp);
            temp--;
        }

        arrayList.add(mid);

        temp = mid + 1;
        while (true) {
            if (temp > 0 || arr[temp] != findval) {
                break;
            }
            arrayList.add(temp);
            temp++;
        }
        return arrayList;
    }
}
```

### 7.3 差值查找

​	二分查找的弊端：若是查找有序数列的头尾的值，茶斋	

差值查找类似于二分查找，常规的二分查找方式，简单说就是让mid 不断向目标值逼近;

**mid=1/2*(left+right)=> mid=low+1/2(left+right)；**

差值查找与之类似，但是，起修改了逼近的方式：

**mid=low+(findVal-arr[left])/(arr[right]-arr[right]) * (right-left);**



### 7.4 斐波那契 查找

## 8、哈希表

​	哈希表也称为散列表是根据关键码值，而直接进行访问的数据结构，，通过将关键码映射到表的摸一个位置进行访问，可以加快查找速度，这个映射函数也叫**散列函数**，存放记录的数组也叫**散列表**；

**例子：**

新员工报道，要求录入新员工信息，当输入员工ID时，找到该员工所有信息；

**要求：**

1、不使用数据库

2、升序排列；

## 9、树

分析顺序存储，以及链式存储的优劣势，树方便存储与读取；

### 9.1 二叉树

每个节点最多只有两个节点，，若二叉树的所有节点都在最后一层，并且节点的总数为 2^n -1 (n为层数)，则该二叉树称为**满二叉树**；

若二叉树的所有叶子结点都在最后一层，或倒数第二层，且最后一层叶子结点在左边连续，倒数第二层叶子结点在右边连续，**则称此二叉树为完全二叉树；**

#### 9.1.1 二叉树遍历

**前序遍历：**先输出父节点、再遍历左子树和右子树；

**中序遍历：**先遍历左子树，在输出父节点，再遍历右子树；

**后续遍历：**先遍历左子树。再遍历右子树，最后输出父节点；

**思路分析：**

1、创建二叉树

**2、前序遍历**

2.1输出当前节点

2.2 左子节点不为空，递归前序遍历

2.3右子节点不为空，递归前序遍历；

**3、中序遍历**

3.1左子节点不为空，中序遍历左子节点

3.2输出当前节点

3.3 右子节点不为空，中序遍历右子节点；

**4、后续遍历**

4.1 左子节点不为空，后续遍历左子节点；

4.2 右子节点不为空，后续遍历右子节点

4.3 输出当前节点；

代码实现

```java
// 1、 定义节点，并在节点中定义，前、中、后、三种遍历方式
class Node {
    int id;
    String Name;

    Node left;
    Node right;

    public Node() {
    }

    public Node(int id, String name) {
        this.id = id;
        Name = name;
    }

    public Node(int id, String name, Node left, Node right) {
        this.id = id;
        Name = name;
        this.left = left;
        this.right = right;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return Name;
    }

    public void setName(String name) {
        Name = name;
    }

    public Node getLeft() {
        return left;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public Node getRight() {
        return right;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "Node{" +
                "id=" + id +
                ", Name='" + Name + '\'' +
                '}';
    }

    // 前序遍历
    public void preOrder() {
        System.out.println(this);
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    // 中序遍历
    public void inFixOrder() {
        if (this.left != null) {
            this.left.inFixOrder();
        }
        System.out.println(this);
        if (this.right != null) {
            this.right.inFixOrder();
        }
    }

    //后续遍历
    public void postOrder() {
        if (this.left != null) {
            this.left.postOrder();
        }
        if (this.right != null) {
            this.right.postOrder();
        }
        System.out.println(this);

    }

}
```



```java 

// 定义一个二叉树
class BinaryTree{
    Node root;

    public void setRoot(Node root){
        this.root=root;
    }

    //前序遍历
    public void preOrder(){
        if (this.root!=null){
            this.root.preOrder();
        }else {
            System.out.println("Tree is Empty");
        }
    }


    //中序遍历
    public void inFixOrder(){
        if (this.root!=null){
            this.root.inFixOrder();
        }else {
            System.out.println("Tree is Empty");
        }
    }

    // 后续遍历
    public void postOrder(){
        if (this.root!=null){
            this.root.postOrder();
        }else {
            System.out.println("Tree is Empty");
        }
    }
}
```



```java
//3、测试
@Test
public void test01(){
    
    //手动 生成二叉树
    BinaryTree binaryTree = new BinaryTree();
    Node root = new Node(1, "xiaoming");
    Node node2 = new Node(2, "xiaofang");

    Node node3 = new Node(3, "xiaogang");
    Node node4 = new Node(4, "xiaowang");


    binaryTree.setRoot(root);
    root.setLeft(node2);
    root.setRight(node3);
    node2.setRight(node4);

  //  binaryTree.preOrder();
   // binaryTree.postOrder();


}
```



#### 9.1.2 二叉树查找

编写前、中、后三种查找方法，并对查找方法进行比较；

思路分析：

前、中、后三种查找方法进行检索，检索指定ID的节点；

**前序查找：**

1、判断当前节点ID是否等于指定ID；

2、若相等则返回当前节点

3、若不相等，则：判断左子节点是否为空，不为空左子节点递归前序查找；

4、若左递归找到目标节点，则返回；

5、若未找到，则右递归 前序查找；

6、若未找到则返回 null ；

```java
//前序查找

public Node preSearch(int no) {

    // 定义一个变量记录返回值
    Node resNode = null;
    if (this.id == no) {
        return this;
    }
    if (this.left != null) {
        resNode = this.left.preSearch(no);
    }
    if (resNode != null) {
        return resNode;
    }
    if (this.right!=null){
        resNode = this.right.preSearch(no);
    }
    return resNode;

}
//中序查找
public Node inFixSearch(int no){
    Node resNode=null;
    if (this.left!=null){
        resNode=this.left.inFixSearch(no);
    }
    if (this.id==no){
        return this;
    }
    if (this.right!=null){
        resNode=this.right.inFixSearch(no);
    }
    return resNode;
}


//后续遍历
public Node postSearch(int no){
    Node resNode=null;
    if (this.left!=null){
        resNode=this.left.postSearch(no);
    }

    if (resNode!=null){
        return resNode;
    }

    if (this.right!=null){
        resNode=this.right.postSearch(no);
    }
    if (this.id==no){
        return this;
    }
    return resNode;

}
```

