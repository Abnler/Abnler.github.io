# IO流

## 一、File类

​	File 对象就代表一个文件或者文件夹，声明在 java.io这个包下；

```java
@Test
public void test01() {

    //1、创建file实例。三种方法
    //2、相对路径：相对于该项目的路径；
    //3、绝对路径：在系统中的路径，带盘符；
    File file = new File("hello.txt");

}

@Test
public void test02() {
    File file = new File("hello.txt");


    //file 的常用获取类方法
    String absolutePath = file.getAbsolutePath();
    String path = file.getPath();
    String name = file.getName();
    String parent = file.getParent();
    long length = file.length();
    long l = file.lastModified();

    //获取指定目录下的文件/文件夹的名称
    String[] list = file.list();
    //获取执行目录下所有文件或者文件目录的file 数组
    File[] files = file.listFiles();

    // 重命名
    //file.renameTo();  file.rename(file2);   要想返回值为true，需确保，file1在硬盘中存在，file2在硬盘中不存在
}

@Test
public void test03() {
    // File 类的判断功能
    File file = new File("hello.txt");

    boolean file1 = file.isFile();  //是否是文件
    boolean directory = file.isDirectory();  //是否为文件目录
    boolean exists = file.exists(); //是否存在
    boolean b = file.canRead(); //可读？
    boolean b1 = file.canWrite();// 可写？
    boolean hidden = file.isHidden();

}

@Test
public void test04() throws IOException {
    // 在硬盘中创建/删除文件（文件目录）
    File file = new File("hello.txt");
    if (!file.exists()){
        file.createNewFile();
    }else {
        file.delete();
    }

    //创建文件目录
    File file1 = new File("hello.txt");
    boolean mkdir = file1.mkdir();
    
    //file.mkdirs();//创建多层目录；
    
}
```

**注意：**在file类中，有对文件，即文件目录有简单的操作，但是并没有，对文件进行读写操作；

## 二、IO流原理及流的分类

I/O Input/Output，Java程序中数据的输入输出方式主要是以流的方式；

### 2.1 数据流分类

- 按照输入输出方向（相较于内存）：输入流、输出流；
- 按照操作数据单位的不同：分为字节流、字符流；
- 按照流的酵素不同：借点六、处理流；

**四个抽象类：**字节流（InputSteam、OutputStream） 字符流（Reader、Weater）

### 2.2 流的体系结构

**抽象基类**                             **节点流**                                     **缓冲流**

InputStream                     FileInputSteam                    BufferInputStream

OutputStream                  FileOutputSteam                BufferOutputStream

Reader                             FileReader                           BufferReader

Writer                              FileWriter                               BufferWriter

### 2.3 数据读标准操作

```java
@Test
public void test01() throws FileNotFoundException {

    FileReader fileReader = null;
    try {
        // 1、实例化file 类
        File file = new File("hello.txt");

        //2、流的实例化 提供具体的流
        fileReader = new FileReader(file);

        //3、数据读入的操作

        while (fileReader.read()!=-1){
            System.out.println(fileReader.read());
        }

    } catch (IOException e) {
        e.printStackTrace();
    }finally {
        try {
            //4、流关闭
            fileReader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
```

- read() 方法，返回读入的一个字符，在文件末尾，返回-1；
- 异常处理，为了保证自愈啊你一定会被执行关闭操作，需要使用try-catch-finally 处理；
- 读入的文件一定要存在，否则会报FileNotFoundException

### 2.3 数据写标准操作

```java
@Test
public void  test02() throws IOException {
    //1、实例化file类
    File file = new File("hello.txt");

    // 2、提供fileWriter对象，
    FileWriter fileWriter = new FileWriter(file);

    // 3、文件写操作
    fileWriter.write("I have a dream");

    //4、流关闭
    fileWriter.close();
    
}
```

- 输出操作，中的file 可以不存在，若是不存在会自动创建，若是存在，是在原有文件的基础上，覆盖或追加；

```java
@Test
public void test03() {

    /**
     * 先将文件读入，然后再写出
     */
    FileReader fileReader = null;
    FileWriter fileWriter = null;

    try {
        // 1、文件实例化
        File sour = new File("source.txt");
        File dest = new File("desc.txt");

        //2、操作流实例化
        fileReader = new FileReader(sour);
        fileWriter = new FileWriter(dest);

        //3、进行读写操作
        char[] cbuf = new char[5];
        int len;
        while ((len = fileReader.read(cbuf)) != -1) {
            fileWriter.write(cbuf, 0, len);
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        //4、关闭流
        try {
            if (fileReader != null)
                fileReader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            fileWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }


}
```

- **不能用字符流，处理图片，音频等字节流操作；**

- **对于文本文件使用字符流处理（.txt,.java,.cpp），对于非文本文件使用字节流处理（图片、视屏、音频、word）；**

```java 
@Test
public void test04() {
    //实现对图片的复制
    FileInputStream fileInputStream = null;
    FileOutputStream fileOutputStream = null;

    try {
        // 1、文件实例化
        File sorfile = new File("hello.jpg");
        File desfile = new File("hello1.jpg");

        //2、实例化流
        fileInputStream = new FileInputStream(sorfile);
        fileOutputStream = new FileOutputStream(desfile);

        //文件读写
        byte[] buffer=new byte[5];
        int len;
        while ((len=fileInputStream.read(buffer))!=-1){
            fileOutputStream.write(buffer,0,len);
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {

        //4 、关闭流
        if (fileInputStream!=null){
            try {
                fileInputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if (fileOutputStream!=null){
            try {
                fileOutputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }

        }
    
    }

}
```

### 2.4 处理流之一--缓冲流

BufferInputStream

BufferOutputStream

BufferReader

BufferWriter

**引入缓冲流的作用：**提高流的读写速率；因为其内部提供了一个缓冲区

**处理流：**就是套接在已有流的基础上

```java 
@Test
    public void test05() {
        // 图片复制

        // 1、文件实例化
        File sorfile = new File("hello.jpg");
        File desfile = new File("hello1.jpg");
        FileInputStream fileInputStream = null;
        FileOutputStream fileOutputStream = null;
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;

        try {
            //2、造流
            //2.1造节点流
            fileInputStream = new FileInputStream(sorfile);
            fileOutputStream = new FileOutputStream(desfile);

            //2.2 造缓冲流
            bis = new BufferedInputStream(fileInputStream);
            bos = new BufferedOutputStream(fileOutputStream);

            //3、读写数据
            byte[] buffer = new byte[10];
            int len;
            while ((len = bis.read(buffer)) != -1) {
                bos.write(buffer, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {

            //4、资源关闭，先关闭外层的流，再关闭内层的流

            if (bos!=null) {
                try {
                    bos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (bis!=null) {
                try {
                    bis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            //关闭外层流的同时，内层流也同步自动关闭
//            fileInputStream.close();
//            fileOutputStream.close();
        }
    }
```

