# Java中的常用类

## 一、字符串相关类

### 1.1 String

​	String字符串类，Java中所有字符串都是由此类实现；  

- String是由final修饰，代表其为不可变字符序列，在创建之后，不能修改；
- 实现了 Comparable 表示String可以比较大小、Serializable 表示字符串是支持序列化的；CharSqqquence 字符串序列
- String 内部定义 final char[] value 用于存储字符串数据；
- String代表不可比拿的字符串序列；简称不可变性；

```Java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];

    /** Cache the hash code for the string */
    private int hash; // Default to 0

    /** use serialVersionUID from JDK 1.0.2 for interoperability */
    private static final long serialVersionUID = -6849794470754667710L;
  .......
}
```

- 通过字面量的方式（区别与new）给一个字符串赋值，此时的字符串声明在字符串常量池中，**注意字符串常量池，是不会存储相同内容的字符的；**

```java 
@Test
public void test09(){

    /**
     * 1、采用字面量的方式定义，声明 s1 s2
     * 比较s1 s2 的值，相等；
     */
    String s1="abc"; //字面量的定义方式
    String s2="abc";

    System.out.println(s1==s2);

    s1="hello"; //s1 重新赋值，岂会在字符串常量池中，重新新建开辟一个空间存放，并将新的地址值赋给s1;
}
```

- 当调用，append,replace 等方法时，都会重新新建一个String 对象，而不是在原String对象上修改；

- String 实例化的两种方式：

  - 通过字面量定义的方式；
  - 通过 new + 构造器的方式；

  ```java
  @Test
  public void test02(){
      // 通过字面量的方式定义，存放在字符串常量池中
      String s1="Java EE" ;
      String s2="Java EE" ;
  
      //通过构造器的方式声明，存放在堆空间中；
      String s3=new String("Java EE") ;
      String s4=new String("Java EE") ;
  
      
      // ==  与equals()的 区别， == 比较的是两个对象的地址，equals比较的是 对象；
      System.out.println(s1==s2); //true 
      System.out.println(s1==s3);// false
      System.out.println(s1==s4);// false
      System.out.println(s3==s4);// false
  
  }
  ```

**面试题：** 通过String s1=new String("" );的方式创建对象，创建了几个对象？

**两个**，一个是堆空间中**new 的对象**，另一个是 **String char[] 型数组中的对象在字符串常量池中**；

- 常量与常亮的拼接结果在常亮池中，常量池中，不会存在相同内容的常量

   只要有一个是变量，结果就在堆中；

   如果拼接的结果调用的是 intern（）方法，返回值就在常亮池中；

```java
//常量与常亮的拼接结果在常亮池中，常量池中，不会存在相同内容的常量
// 只要有一个是变量，结果就在堆中；
// 如果拼接的结果调用的是 intern（）方法，返回值就在常亮池中；
public void test10(){
    String s1="hello";
    String s2="world";


    String s3="helloworld";
    String s4="hello"+"world";
    String s5=s1+"world";
    String s6="hello"+s2;
    String s7=s1+s2;
    String s8=s5.intern();  //返回值中的，使用的是常量池中的已存在的东西；

    System.out.println(s3==s4);//true
    System.out.println(s3==s5);//false
    System.out.println(s3==s7);//false
    System.out.println(s4==s7);//false
    System.out.println(s3==s8);//true

}
```

- String 的常用方法

- String与其他数据类型、包装类的转换

  ```Java
  @Test
  public void test11(){
      //1、String --> 基本数据类型、包装类 parseXxx(Str);
      String s1="123";
      int num = Integer.parseInt(s1);
  
      //2、将基本数据类型-->String
      int number =1234;
      String str1 = String.valueOf(number);
      
  }
  ```

- 字符串与字符数组之间的转换（String<--->char[]）

  ```Java
  @Test
  public void test12(){
      //1、String -> char[]
      String str2="abcdew";
      char[] chars = str2.toCharArray();
  
      //char[]->String
      char[] shc={'1','2','3'};
      String str3=new String(shc);
  }
  ```

- 字符串与字节数组之间的转化（String <-->byte[]）

  ```Java
  @Test
  public void test13() throws UnsupportedEncodingException {
      //1、String -->byte[]   返回的是对应字符的ascall 码值组成的数组；
      String str1 = "abc2345567";
      byte[] bytes = str1.getBytes();  //使用默认的字符集，进行转换。
  
      byte[] gbks = str1.getBytes("gbk");//使用指定的字符集，进行转换。
  
  
      //2、byte[]-->String 调用String的构造器
      String str2 = new String(bytes);
      String str3 = new String(gbks, "gbk");//使用指定的字符集，进行解码。
  }
  ```

  

### 1.2 StringBuffer 以及StringBuilder

**面试题：String、StringBuffer、StringBuilder的三者的异同**

**String：**不可变的字符序列；使用char[] 数组

**StringBuffer：可变**的字符序列，线程安全的，效率低；（实现了各种同步的方法）,继承自**AbstractStringBuilder**，底层由char[] 数组实现；

**StringBuilder：**可变的字符序列，线程不安全，但是效率高；继承自**AbstractStringBuilder**，底层由char[] 数组实现；



源码分析：

- String

  ```java 
  String str1=new String();  // char[] value=new char[0];
  String Str2=new String("abc");//char[] value=new char[]{'a','b','c'}
  ```

- StringBuffer、StringBuilder

  ```Java
  StringBuffer stringBuffer1=new StringBuffer();//char[] value=new char[16] ,默认的的容量是16；
  stringBuffer1.append('a'); //value[0]=a;
  stringBuffer1.append('b');//value[1]=b;
  
  StringBuffer stringBuffer2=new StringBuffer("abc");// char[] value=new char["abc".length+16];
  ```

```Java
//问题：stringBuffer2.length() 是多少？ 3； 这个算的是count，而不是char[].length;
//问题：如何扩容，默认情况下，扩容为原来的两杯2倍+2；同时将原有数组中的元素，放入新数组；
```



**StringBuffer 以及StringBuilder 常用函数**

```java
StringBuffer str1= new StringBuffer("abc");
str1.append(1);  //增加
str1.delete(0,2); //删除，左闭右开
str1.insert(1,false);//在指定序列插入
str1.reverse();//反转
String s = str1.substring(1, 2);//截取字串,返回一个新的字符串，原来的字符串不变
int i = str1.indexOf("1");//查看出现 目标字符，所在的位置
char c = str1.charAt(0);//查看第i个位置，的字符是什么
```



## 二、日期时间

- Java.lang.System 

  - Publiv static long currentTimeMills() 返回当前时间与1970年1月1日0时0分一毫秒为单位的时间差；

  ```java
  //返回时间戳
  long timeMillis = System.currentTimeMillis();
  ```

- Java.util.Date

  ```java
  //1、构造器1 Date()创建了一个当前时间的的Date对象
  Date date1 = new Date();
  
  //2、构造器2，创建指定毫秒数的构造器
  Date date2 = new Date(21314543); //其中的参数是时间戳
  
  //3、toString（），以及getTime（）
  System.out.println(date1.toString());//返回的是标准时间
  System.out.println(date1.getTime());//返回的是时间戳，
  ```

- Java.sql.Date 对应数据哭中的日期类型的变量

  ```java
  //创建一个java.sql.Date 对象
  java.sql.Date date3 = new java.sql.Date(23121432);
  ```

- SimpleDateFormate

- Calendar日历类，是一个抽象类；其常用子类为 Gregory；

- JDK 8.0之后的新增的.API 

  LocaDate LocalDateTime LocalTime;

  

