# Mybatis

## 一、Mybatis 初体验

### 1.1 Mybatis 简介

​	**mybatis** 是一款同数据库打交到的ORM （Object Relation Mapping）框架，采用；是对原来的 JDBC，DBUtil，jdbcTemplate 的丰富；

![image-20210119104433413](/Users/anner/Library/Application Support/typora-user-images/image-20210119104433413.png)

**Hibernate：**全自动全映射ORM（Object Relation Mapping）框架；旨在消除sql，**HQL**

![image-20210119104619162](/Users/anner/Library/Application Support/typora-user-images/image-20210119104619162.png)

但是由于，SQL语句，大多无法定制化，HQL，增加了学习难度；希望：sql语句交给我们开发人员编写，希望sql不失去灵活性；

**Mybatis：**是一款半自动，请谅解的框架，Sql与java编码分离，将sql语句以配置文件的方式传入；sql是开发人员控制

![image-20210119104830437](/Users/anner/Library/Application Support/typora-user-images/image-20210119104830437.png)

### 1.2 Mybatis - Helloword

**第一步：引入相应依赖**

```xml
<!--        mybatis  jar包-->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.3.0</version>
</dependency>
<!-- mysql驱动包 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.22</version>
</dependency>

<!--log4j-->
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-api</artifactId>
    <version>2.14.0</version>
</dependency>
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.14.0</version>
</dependency>

<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.11</version>
    <scope>test</scope>
</dependency>
```

**第二步：类& 表的创建**

```java
public class Employee {
    private Integer id;
    private String lastName;
    private String email;
    private String gender;

    public Employee(String lastName, String email, String gender) {
        this.lastName = lastName;
        this.email = email;
        this.gender = gender;
    }

    public Employee() {
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "id=" + id +
                ", lastName='" + lastName + '\'' +
                ", email='" + email + '\'' +
                ", gender='" + gender + '\'' +
                '}';
    }
}
```

```sql
create table tbl_employee
(
    id        int auto_increment
        primary key,
    last_name varchar(25)  null,
    gender    char         null,
    email     varchar(255) null
);
```

注意：表字段与类属性的相互对应；

**第三步：mybatis 的相关配置**

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://192.168.234.7:3306/userDb?useSSL=true&amp;useUnicode=true&amp;"/>
                <property name="username" value="root"/>
                <property name="password" value="root"/>
            </dataSource>
        </environment>
    </environments>
   <!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 -->
    <mappers>
        <mapper resource="EmployeeMapper.xml"/>
    </mappers>
</configuration>
```

**第四步： mapper&& intyerface DAO** 

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.restart.dao.EmployeeMapper">
<!-- 
namespace:名称空间;指定为接口的全类名
id：唯一标识
resultType：返回值类型
#{id}：从传递过来的参数中取出id值

public Employee getEmpById(Integer id);
 -->
   <select id="getEmpById" resultType="com.restart.bean.Employee">
      select id,last_name lastName,email,gender from tbl_employee where id = #{id}
   </select>
</mapper>
```

```java
public interface EmployeeMapper {

    public Employee getEmpById(Integer id);
}
```

**第五步：TEST**

```java
/**
 * 1、接口式编程
 * 	原生：		Dao		====>  DaoImpl
 * 	mybatis：	Mapper	====>  xxMapper.xml
 * 
 * 2、SqlSession代表和数据库的一次会话；用完必须关闭；
 * 3、SqlSession和connection一样都是非线程安全。每次使用都应该去获取新的对象。
 * 4、mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象。
 * 		（将接口和xml进行绑定）
 * 		EmployeeMapper empMapper =	sqlSession.getMapper(EmployeeMapper.class);
 * 5、两个重要的配置文件：
 * 		mybatis的全局配置文件：包含数据库连接池信息，事务管理器信息等...系统运行环境信息
 * 		sql映射文件：保存了每一个sql语句的映射信息：
 * 					将sql抽取出来。	
 * 
 */
 
public class Test {

    public SqlSessionFactory getSqlSessionFactory() throws IOException {
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        return new SqlSessionFactoryBuilder().build(inputStream);
    }


    @org.junit.Test
    public void test02() throws IOException {
        // 1、获取sqlSessionFactory对象
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        // 2、获取sqlSession对象
        SqlSession openSession = sqlSessionFactory.openSession();
        try {
            // 3、获取接口的实现类对象
            //会为接口自动的创建一个代理对象，代理对象去执行增删改查方法
            EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);
            Employee employee = mapper.getEmpById(1);
            System.out.println(mapper.getClass());
            System.out.println(employee);
        } finally {
            openSession.close();
        }
    }

    /**
     * 1、根据xml配置文件（全局配置文件）创建一个SqlSessionFactory对象 有数据源一些运行环境信息
     * 2、sql映射文件；配置了每一个sql，以及sql的封装规则等。
     * 3、将sql映射文件注册在全局配置文件中
     * 4、写代码：
     *        1）、根据全局配置文件得到SqlSessionFactory；
     *        2）、使用sqlSession工厂，获取到sqlSession对象使用他来执行增删改查
     *           一个sqlSession就是代表和数据库的一次会话，用完关闭
     *        3）、使用sql的唯一标志来告诉MyBatis执行哪个sql。sql都是保存在sql映射文件中的。
     */
    @org.junit.Test
    public void test01() throws Exception {
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();

        SqlSession openSession = sqlSessionFactory.openSession();
        // 2、获取SQLsession实例，执行已经映射的sql语句
        // sql的唯一标识：statement Unique identifier matching the statement to use.
        // 执行sql要用的参数：parameter A parameter object to pass to the statement.

        try {

            Employee tom = openSession.selectOne("com.restart.EmployeeMapper.selectEmp", 1);
            System.out.println(tom);
        }finally {

            openSession.close();
        }

    }
}
```

## 二、mybatis 全局配置文件



```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!--
    Properties 属性
        1、mybatis可以使用properties来引入外部properties配置文件的内容；
      resource：引入类路径下的资源
      url：引入网络路径或者磁盘路径下的资源
      2、以下是引入 数据库配置文件
    -->
    <properties resource="dbconfig.properties"></properties>

    <!--
      2、settings包含很多重要的设置项
      setting:用来设置每一个设置项
          name：设置项名
          value：设置项取值
      -->
    <settings>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>

    <!-- 3、typeAliases：别名处理器：可以为我们的java类型起别名
        别名不区分大小写
       -->
    <typeAliases>
        <!-- 1、typeAlias:为某个java类型起别名
                type:指定要起别名的类型全类名;默认别名就是类名小写；employee
                alias:指定新的别名
         -->
        <!-- <typeAlias type="com.atguigu.mybatis.bean.Employee" alias="emp"/> -->

        <!-- 2、package:为某个包下的所有类批量起别名
                name：指定包名（为当前包以及下面所有的后代包的每一个类都起一个默认别名（类名小写），）
        -->
        <package name="com.atguigu.mybatis.bean"/>

        <!-- 3、批量起别名的情况下，使用@Alias注解为某个类型指定新的别名 -->
    </typeAliases>

    <!--
      4、environments：环境们，mybatis可以配置多种环境 ,default指定使用某种环境。可以达到快速切换环境。
         environment：配置一个具体的环境信息；必须有两个标签；id代表当前环境的唯一标识
            transactionManager：事务管理器；
               type：事务管理器的类型;JDBC(JdbcTransactionFactory)|MANAGED(ManagedTransactionFactory)
                  自定义事务管理器：实现TransactionFactory接口.type指定为全类名

            dataSource：数据源;
               type:数据源类型;UNPOOLED(UnpooledDataSourceFactory)
                        |POOLED(PooledDataSourceFactory)
                        |JNDI(JndiDataSourceFactory)
               自定义数据源：实现DataSourceFactory接口，type是全类名
       -->

    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url"
                          value="${jdbc.url}?useSSL=true&amp;useUnicode=true&amp;"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>

        <environment id="dev_oracle">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${orcl.driver}"/>
                <property name="url" value="${orcl.url}"/>
                <property name="username" value="${orcl.username}"/>
                <property name="password" value="${orcl.password}"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 5、databaseIdProvider：支持多数据库厂商的；
       type="DB_VENDOR"：VendorDatabaseIdProvider
         作用就是得到数据库厂商的标识(驱动getDatabaseProductName())，mybatis就能根据数据库厂商标识来执行不同的sql;
         MySQL，Oracle，SQL Server,xxxx
     -->
    <databaseIdProvider type="DB_VENDOR">
        <!-- 为不同的数据库厂商起别名 -->
        <property name="MySQL" value="mysql"/>
        <property name="Oracle" value="oracle"/>
        <property name="SQL Server" value="sqlserver"/>
    </databaseIdProvider>

    <!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 -->
    <mappers>
        <!--
         mapper:注册一个sql映射
            注册配置文件
            resource：引用类路径下的sql映射文件
               mybatis/mapper/EmployeeMapper.xml
            url：引用网路路径或者磁盘路径下的sql映射文件
               file:///var/mappers/AuthorMapper.xml

            注册接口
            class：引用（注册）接口，
               1、有sql映射文件，映射文件名必须和接口同名，并且放在与接口同一目录下；
               2、没有sql映射文件，所有的sql都是利用注解写在接口上;
               推荐：
                  比较重要的，复杂的Dao接口我们来写sql映射文件
                  不重要，简单的Dao接口为了开发快速可以使用注解；
      -->
        <!-- <mapper resource="mybatis/mapper/EmployeeMapper.xml"/> -->
        <!-- <mapper class="com.atguigu.mybatis.dao.EmployeeMapperAnnotation"/> -->

        <!-- 批量注册： -->
        <mapper resource="EmployeeMapper.xml"/>
        <mapper class="com.restart.dao.EmployeeMapperAnnotation"/>
    </mappers>
</configuration>
```

## 三、Mybatis 映射文件

### 3.1 增删改查

**第一步 ：声明相关接口** 

```java
// 方式一： 直接在接口上  写明 sql语句
public interface EmployeeMapperAnnotation {
    @Select("select * from tbl_employee where id=#{id}")
    public Employee getEmpById(Integer id);

    @Insert("insert into tbl_employee(last_name,email,gender) values (#{lastName},#{email},#{gender})")
    public void addEmp(Employee employee);

    @Update("update tbl_employee\n" +
            "\t\t\tset last_name=#{lastName},email=#{email},gender=#{gender}\n" +
            "\t\t\twhere id=#{id}")
    public void updateEmp(Employee employee);

    @Delete("delete from tbl_emplo yee where id=#{id}")
    public void deleteEmpById(Integer id);
}
```

```xml
<!-- 方法二：sql语句抽离到 xml文件中-->

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.restart.dao.EmployeeMapper">
<!-- 
namespace:名称空间;指定为接口的全类名
id：唯一标识
resultType：返回值类型
#{id}：从传递过来的参数中取出id值

public Employee getEmpById(Integer id);
 -->
   <select id="getEmpById" resultType="com.restart.bean.Employee" databaseId="mysql">
      select id,last_name lastName,email,gender from tbl_employee where id = #{id}
   </select>

   <!--useGeneratedKeys="true" keyProperty="id" 调用自增主键，并且指明主键 -->
   <insert id="addEmp" parameterType="com.restart.bean.Employee" databaseId="mysql" 
         useGeneratedKeys="true" keyProperty="id">
      insert into tbl_employee(last_name,email,gender) values (#{lastName},#{email},#{gender})
   </insert>
   
   <update id="updateEmp" >
      update tbl_employee
         set last_name=#{lastName},email=#{email},gender=#{gender}
         where id=#{id}
   </update>

   <delete id="deleteEmpById">
      delete from tbl_employee where id=#{id}
   </delete>
</mapper>
```



**第二步:测试**

```java
@org.junit.Test
public void testDelete() throws IOException {
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
    SqlSession openSession = sqlSessionFactory.openSession(true);  // 自动提交
    try {

        EmployeeMapperAnnotation mapper = openSession.getMapper(EmployeeMapperAnnotation.class);
        mapper.deleteEmpById(1);
    } finally {
        openSession.close();
    }
}


@org.junit.Test
public void testupdate() throws IOException {
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
    SqlSession openSession = sqlSessionFactory.openSession(true);
    try {

        EmployeeMapperAnnotation mapper = openSession.getMapper(EmployeeMapperAnnotation.class);

        Employee Jary = new Employee(1,"Jary", "jary@gmail.com", "1");

        mapper.updateEmp(Jary);

    } finally {
        System.out.println(111);
        openSession.close();
    }
}

@org.junit.Test
public void testInsert() throws IOException {
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
    SqlSession openSession = sqlSessionFactory.openSession(true);
    try {

        EmployeeMapperAnnotation mapper = openSession.getMapper(EmployeeMapperAnnotation.class);

        Employee jary = new Employee(null,"Ray", "Ray@gmail.com", "0");

        mapper.addEmp(jary);
    } finally {
        System.out.println(111);
        openSession.close();
    }
}
```

### 3.2 Mybatis  参数处理

**单个参数：**mybatis不会做特殊处理，
	#{参数名/任意名}：取出参数值。

**多个参数**：mybatis会做特殊处理。
	多个参数会被封装成 一个map，
		key：param1...paramN,**或者参数的索引也可以**
		value：传入的参数值
	#{}就是从map中获取指定的key的值；
	

```java
异常：
org.apache.ibatis.binding.BindingException: 
Parameter 'id' not found. 
Available parameters are [1, 0, param1, param2]
操作：
	方法：public Employee getEmpByIdAndLastName(Integer id,String lastName);
	取值：#{id},#{lastName}
```

【命名参数】：明确指定封装参数时map的key；@Param("id")
	多个参数会被封装成 一个map，
		key：使用@Param注解指定的值
		value：参数值
	#{指定的key}取出对应的参数值

```java
public interface EmployeeMapper {

    public Employee getEmpById(@Param("id") Integer id, @Param("lastname") String lastName);
}
```

**POJO：**
如果多个参数正好是我们业务逻辑的数据模型，我们就可以直接传入pojo；
	#{属性名}：取出传入的pojo的属性值	

**Map：**
如果多个参数不是业务模型中的数据，没有对应的pojo，不经常使用，为了方便，我们也可以传入map
	#{key}：取出map中对应的值;

**TO：**
如果多个参数不是业务模型中的数据，但是经常要使用，推荐来编写一个TO（Transfer Object）数据传输对象
Page{
	int index;
	int size;
}

#### 思考

```java
//========================思考================================	
public Employee getEmp(@Param("id")Integer id,String lastName);
	//取值：id==>#{id/param1}   lastName==>#{param2}

public Employee getEmp(Integer id,@Param("e")Employee emp);
	//取值：id==>#{param1}    lastName===>#{param2.lastName/e.lastName}

/**##特别注意：如果是Collection（List、Set）类型或者是数组，
		 也会特殊处理。也是把传入的list或者数组封装在map中。
			key：Collection（collection）,如果是List还可以使用这个key(list)
				数组(array)
*/
public Employee getEmpById(List<Integer> ids);
//	取值：取出第一个id的值：   #{list[0]}


```

