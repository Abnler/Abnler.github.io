[TOC]

# 多线程于并发

## 一、进程与线程

### 1.1 概念	

​	**程序：** 为完成特定任务，用某种编程语言编写的一组指令集合；

​	**进程：**是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位；

​	**线程：**是进程的一次执行路径，一个进程至少有一个线程，进程中的多个线程共享进程的资源。虽然进程是资源分配与调度的基本单位，但是CPU是被分配到线程级的，线程是CPU分配的基本单位；

### 1.2 关系与区别

​	**关系**：一个进程中有多个线程，多个线程**共享进程的堆、方法区资源，**但是每个线程有自己的程序**计数器和栈区域**；

- **堆**：存放对象、数组，是 JVM 内存中最大的一块内存空间，该内存被所有线程共享；
- **方法区**：主要用来存放虚拟机加载的倍的相关信息（类信息、常量池、运行时常量池），例如类的版本，字段，方法，接口，父类；
- **程序计数器**：记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器；程序计数器和上下文切换有关；
- **虚拟机栈（VM Stack）**:虚拟机栈是线程私有的内存空间，它和 Java 线程一起创建。当创建一个线程时，会在虚拟机栈中申请一个线程栈，用来保存方法的局部变量、操作数栈、动态链接方法和返回地址等信息，并参与方法的调用和返回。每一个方法的调用都伴随着栈帧的入栈操作，方法的返回则是栈帧的出栈操作。
- **本地方法栈（Native Method Stack）**:本地方法栈跟虚拟机栈的功能类似，虚拟机栈用于管理 Java 方法的调用，而本地方法栈则用于管理本地方法的调用。但本地方法并不是用 Java 实现的，而是由 C 语言实现的;

**区别：**

**进程**：有独立的地址空间，一个进程奔溃后，不会对其他进程产生影响；

**线程：**是进程中的不同执行路径，线程有自己的堆栈，局部变量；

- 一个程序至少有一个进程，一个进程至少有一个线程；
- 线程的划分尺度小于进程，使得线程程序的并发性高；
- 进程执行中，有独立的内存单元，而多个线程共享内存；
- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别；

### 1.3 多线程的优点

- 提高程序的响应，增强用户的体验；
- 提高CPU的利用率；
- 改善陈旭结构，将悠长又复杂的进程分成多个线程，独立运行，利于理解和修改；

##  二、并行与并发

**并发：**是指同一个**时间段内**多个任务同时都在执行，并且都没有执行结束。并发任务强调在一个时间段内同时执行，而一个时间段由**多个单位时间**累积而成，所以说并发的多个任务在单位时间内不一定同时在执行 。

**并行：**是说在**单位时间内**多个任务**同时在执行** 。

## 三、线程的实现方式

​	**Java 中实现多线程**有两种手段，一种是**继承Thread类**，一种是**实现Runnable接口**；

### 3.1 继承 Thread类

- 创建一个继承Thread 的子类
- 重写Thread的run方法；
- 创建Thread 的子类的对象；
- 子类对象调用start() 方法；

Start 方法的作用：

- 启动当前线程；
- 调用线程的run()  方法；

Q：若是通过线程的子类对象直接调用 run()方法，这个是吃否会启动这个子类线程呢？？

A：通过子类对象直接调用run() 方法，不能启动子类线程； 这里只是体现的是对象调用方法。 并没有启动子类线程；

不能通过已经调用start（） 方法的线程，再次调用start（） 方法，重新启动一个新的线程；

若要重新启动一个线程，则需要重新new 一个对象，再用对象调用start（） 方法；



```java
class MyThread extends Thread{
	private String name;
	public MyThread(String name){
		name=this.name;
	}

	public void run(){//一定要重写run() 方法

	}
}
```
### 3.2 实现Runnable 接口

```java
class MyThread implements Runnable{
	private String name;
	public MyThread(String name){
		name=this.name;
	}

	public void run(){//一定要重写run() 方法

	}
}
```
两种方式都有线程安全的情况，没有解决；



**两种实现方式的差别：**

1、开发中优先选择runable接口的方式；

2、实现的方式，没有类的单继承的局限性；

3、 实现的方式更适合来处理多个线程共享数据的情况；

4、两者的联系，其实Thread 类，源码也是实现runable接口；

5、无论是继承Thread还是实现runable 接口，都需要重写 run() 方法；

线程分类：

- 守护线程
- 用户线程

一个java应用程序，至少有三个线程，一个main() 主线程（用户线程），一个gc() 垃圾回收线程（守护线程），一个异常处理线程（守护线程）；守护线程随着用户线程的结束而结束；



### 3.3 线程的状态变化

**Thread 中有一个枚举类State，定义了线程的几个状态，NEW，RUNABLE，BLOCK，WAITING，TIMED_WAITING,TERMINATE** 

线程一般有5个状态，**创建、就绪、运行、阻塞、终止**；

- **创建状态**：线程对象初始化后，新的线程就处于新建状态，此时已给他分配相应的内存空间，但是暂处于不可运行状态； eg： Thread th=new Thread();
- **就绪状态**：线程对象创建后，该线程调**用start()** 方法启动该线程，党线程启动时，线程就进入就绪状态，此时线程进入线程队列排毒，等待CPU服务，此时已具备运行条件；eg: th.start（）；
- **运行状态**：线程处于就绪转状态后，获得CPU资源时，线程就进图运行状态；此时**自动调用run()方法；**
- **阻塞状态**：一个正在执行的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入/输出操作，会让 CPU 暂时中止自己的执行，进入阻塞状态。在可执行状态下，如果**调用sleep(),suspend(),wait() 等**方法，线程都将进入阻塞状态，发生阻塞时线程不能进入排队队列，只有当引起阻塞的原因被消除后，线程才可以转入就绪状态。
- **死亡状态**：线程调用 **stop() 方法时或 run() 方法执行结束后**，即处于死亡状态。处于死亡状态的线程不具有继续运行的能力。![线程状态转换](D:\Can't forget what you want\Process\Base\线程状态转换.png)

### 3.4 Thread中的常用方法

- start() : 启动当前线程，调用当前线程的run() 方法；
- Run() ：通常需要重写Thread 类中的此方法，将创建的线程需要执行的操作，在此声明；
- currentThread(): 静态方法，返回执行单线代码的线程；
- getNam():获取当前线程的名字；
- setName():设置当前线程名字；
- yield(): 释放当前cpu的执行权；
- join()：在线程a中线程b调用join（）方法，此时线程a就进入了阻塞状体，直到线程b执行完之后，线程a才从阻塞状态中解除；
- stop() ：强制让当前线程结束，该方法已过时；
- sleep(long mintime)： 让当前线程进入睡眠； 静态方法，让当前线程，强制阻塞，  在mintime 毫秒时间内；
- isAlive():判断当前线程是否执行完毕；是否还存活；
- Wait()
- Notify()
- Notyifyall() 线程通讯的三个方法；  这三个方法，不是定义在thread 中，而是，定义在object类中,应用于线程通讯中；

### 3.5 线程的调度

​	一般情况下有两种方式采用时间片的调度策略，分时服务；抢占式，高优先级的线程抢占CPU；

Java的调度方式：

- 同优先级的采用先进先出，先到先服务，使用时间片策略；
- 对高优先级的，采用抢占式的方式；

常量：

- MAX_PRIORITY       10
- NORM_PRIORITY    5
- min_PRIORITY    5  

Java 中线程的优先级分为10个，设有以上三个常量；以及两个方法getPriority(). setPriority();

默认优先级为NORM_PRIORITY； 



## 四、线程池

暂定；