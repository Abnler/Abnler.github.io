# 常用算法实现

## 一、二分查找

### 1.1 二分查找非递归实现

```java
public class BinarySearch {


    /**
     * 二分查找非递归实现
     *
     * @param arr    待查找数组.生序排列
     * @param target 目标
     * @return 若找到返回下标，没找到返回-1
     */
    public static int binarySearch(int[] arr, int target) {

        int left = 0;
        int right = arr.length - 1;

        while (left <= right) {
            int mid = (left + right) / 2;
            if (arr[mid] == target) {
                return mid;
            } else if (mid > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1;
    }

    /**
     * 二分查找递归实现
     *
     * @param arr    待查找数组.生序排列
     * @param target 目标
     * @return 若找到返回下标，没找到返回-1
     */
    public int binarySearchRec(int[] arr, int target, int left, int right) {
        left = 0;
        right = arr.length - 1;
        int mid = (left + right) / 2;
        if (left < right) {
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] > target) {
                return binarySearchRec(arr, target, left, mid - 1);
            } else {
                return binarySearchRec(arr, target, mid + 1, right);
            }
        }
        return -1;
    }

    @Test
    public void test01() {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 89};
        System.out.println(binarySearchRec(arr,4,0,arr.length));
        System.out.println(binarySearch(arr,4));
    }

}

```

##  二、分治算法

​	**分而治之**，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法([快速排序](http://www.cnblogs.com/xsyfl/p/6901315.html)，[归并排序](http://www.cnblogs.com/xsyfl/p/6905974.html))，傅立叶变换(快速傅立叶变换)……

**分治法在每一层递归上都有三个步骤：**

1)分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题

2)解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题

3)合并：将各个子问题的解合并为原问题的解。

### 2.1 汉诺塔

1)如果是有一个盘， A->C

如果我们有 n >= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘

1)先把 最上面的盘 A->B

2)把最下边的盘 A->C

3)把B塔的所有盘 从 B->C  

```java
public class HanoiTowerDemo {


    public static void hanoiTower(int num,char a,char b,char c){
       if (num==1){
           System.out.println(a+"->"+c);
       }else{
           // 若n>1,则，我们可以把盘子分为两部分，把上面的n-1个当作第一一个，第n个当作第二个；
           //把第一个移到 A-B，移动过程中回用到c
           hanoiTower(num-1,a,c,b);
           System.out.println("第"+num+"步"+a+"->"+c);
           //再把B上面的盘子，从B->c，移动过过程中回用到
           hanoiTower(num-1,b,a,c);

       }
    }

    @Test
    public void test02(){
        hanoiTower(3,'a','b','c');
    }
```

## 三、动态规划算法

![image-20201231213128083](/Users/anner/Library/Application Support/typora-user-images/image-20201231213128083.png)

01背包问题，不超出容量，要求价值最大；

1)动态规划(**Dynamic Programming**)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法

2)与分治法不同的是，**适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。** ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )

**思路：**

```java
算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：

(1) v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是0

(2) 当w[i]> j 时：v[i][j]=v[i-1][j]  // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略

(3) 当j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} 

// 当 准备加入的新增的商品的容量小于等于当前背包的容量,
// 装入的方式:
v[i-1][j]： 就是上一个单元格的装入的最大值
v[i] : 表示当前商品的价值 
v[i-1][j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值
当j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} 
```

